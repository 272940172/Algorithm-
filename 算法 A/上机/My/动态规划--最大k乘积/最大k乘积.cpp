// ConsoleApplication53.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"



// ######################################################################## //
//
//  本程序使用动态规划法解决 '最大 k 乘积' 问题.
//
//  创建日期: 2016-04-03
//
//  修改记录:
//  ( 1 ) 2016-04-03 创建了初始版本( v0.10 )
//
//  版 本 号: v0.10
//
//  备    注: 使用标准 C 代码实现
//
//  作    者: 刘伟
//
// ######################################################################## //

// 使用的库定义
#include < stdio.h >
#include < stdlib.h >
#include < string.h >

// ######################################################################## //
//                                                                          // 
//                              下面是数据定义区                               // 
//                                                                          // 
// ######################################################################## //

#define STR_LEN 100
#define TRUE    1
#define FALSE   0

//////////////////////////////////////////////////////////////////////////////


// ######################################################################## //
//                                                                          // 
//                           下面是各个子函数定义                               // 
//                                                                          // 
// ######################################################################## //

int  CalcMaxKProduct(int n, int k, int **D, int **P);
void PrintProductMatrix(int n, int k, int **D, int **P);

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                          下面是各个子函数的实现                             // 
//                                                                          // 
// ######################################################################## //

// 使用动态规划法计算两个字符串之间的编辑距离 ...
//
// 测试数据如下 :
// ( 1 ) 1234 划分为 3 段 : 12 * 3 * 4 = 144
// ( 2 ) 自行设计 2 个测试用例
int CalcMaxKProduct(int n, int k, int **D, int **P)
{
	int i, j, t, maxv, tk;

	// 请将下面的代码补充完毕, 使程序可以正确运行 ...
	// ......
	//D==w
	//p==m
	if (k == 1) {
		return D[1][n];
	}
	else {
		for (i = 1; i < n + 1; i++) {
			P[i][1] = D[1][i];
		}
		printf("#\n");
		printf("%d\n", n);
		printf("%d\n", k);
		for (i = 1; i <= n; i++) {
			printf("%d  ", i);
			for (j = 2; j <= k; j++) {
				int max = 0;//maxv
				int g;//t
				for (g = 1; g < i; g++) {
					int temp = P[g][j - 1] * D[g + 1][i];

					if (temp > max) {
						max = temp;
					}
				}
				P[i][j] = max;
			}
		}

		return P[n][k];
	}

}

// 打印编辑距离矩阵 ...
void PrintProductMatrix(int n, int k, int **D, int **P)
{
	int i, j;

	// 打印 'D' ...
	printf("\t生成的整数分段值矩阵为 : \n");

	// 请将下面的代码补充完毕, 使程序可以正确运行 ...
	// ......
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			printf("%d\t", D[i][j]);
		}
		printf("\n");
	}

	printf("\n\n");

	// 打印 'P' ...
	printf("\t生成的分段乘积矩阵为 : \n");

	// 请将下面的代码补充完毕, 使程序可以正确运行 ...
	// ......
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= k; j++)
		{
			printf("%d\t", P[i][j]);
		}
		printf("\n");
	}

	printf("\n\n");
}

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                             下面是主程序的实现                              // 
//                                                                          // 
// ######################################################################## //

void main(void)
{
	char StrI[STR_LEN];
	char StrK[STR_LEN];
	int  *I, n;    // 储存输入的整数及其长度 ...
	int  k;        // 输入的整数分为 'k' 段 ...
	int  **D, **P; // 二维数组, 储存整数的各个分段值及乘积值 ...
	int  i, j, MaxProduct;
	int  IsStop;

	IsStop = FALSE;
	while (!IsStop)
	{
		// 清屏 ...
		system("cls");

		// 输入整数 'I' ...
		printf("\n\n\t请输入 < 整数 I 的值 > ， 输入 < q / Q > 表示结束 : ");
		scanf("%s", StrI);
		n = strlen(StrI); // 输入整数的位数 ...
		if (n > 0)
			IsStop = ((StrI[0] == 'q') || (StrI[0] == 'Q'));
		else
			printf("\t输入的整数不能为空 !\n\n");

		if (!IsStop)
		{
			// 输入分段数 'k' ...
			printf("\n\t请输入 < 整数分段数 k > ， 输入 < q / Q > 表示结束 : ");
			scanf("%s", StrK);
			if (strlen(StrK) > 0)
				IsStop = ((StrK[0] == 'q') || (StrK[0] == 'Q'));
			else
				printf("\t输入的整数分段数不能为空 !\n\n");

			// 输入的整数及其分段数 'I' 和 'k' 均不为空, 则计算最大 'k' 乘积 ...
			if (!IsStop)
			{
				// 将输入的字符串转换为整数 ...

				// 输入的整数 'I' ...

				// 动态申请一维数组 ...
				I = (int *)malloc((n + 1) * sizeof(int));

				// 将输入的字符串整数的每一位放入 'I' 中 ...
				for (i = 1; i <= n; i++)
					I[i] = StrI[i - 1] - '0'; // 注意序号起始值 ...

											  // 输入的分段数 'k' ...
				k = atoi(StrK);

				// 动态申请二维数组 'D' 和 'P' ...

				// 'D' - 储存整数的各个分段值( n x n 阵 ) ...相当于W
				D = (int **)malloc((n + 1) * sizeof(int));
				for (i = 0; i <= n; i++)
					D[i] = (int *)malloc((n + 1) * sizeof(int));
				// 初始化 ...
				for (i = 0; i <= n; i++)
					for (j = 0; j <= n; j++)
						D[i][j] = 0;

				// 'P' - 储存整数的分段乘积值( n x k 阵 ) ...相当于m矩阵
				P = (int **)malloc((n + 1) * sizeof(int));
				for (i = 0; i <= n; i++)
					P[i] = (int *)malloc((k + 1) * sizeof(int));
				// 初始化 ...
				for (i = 0; i <= n; i++)
					for (j = 0; j <= k; j++)
						P[i][j] = 0;

				// 生成 'D' 矩阵 ...

				// 请将下面的代码补充完毕, 使程序可以正确运行 ...
				// ......
				for (i = 1; i <= n; i++) {
					D[i][i] = I[i];
					for (j = i + 1; j <= n; j++) {
						D[i][j] = D[i][j - 1] * 10 + I[j];
					}
				}

				// 计算最大 'k' 乘积 ...
				MaxProduct = CalcMaxKProduct(n, k, D, P);

				// 显示计算结果 ...
				printf("\n\t< 计算得到的最大 k 乘积为：%d > \n\n", MaxProduct);

				// 打印数值矩阵 ...
				PrintProductMatrix(n, k, D, P);

				// 释放二维数组 'D' 和 'P' 的空间 ...
				for (i = 0; i <= n; i++)
					free(D[i]);
				free(D);

				for (i = 0; i <= n; i++)
					free(P[i]);
				free(P);

				// 等待用户输入任意一键返回 ...
				printf("\n\n");
				system("PAUSE");
			}
		}
	}

	// 等待用户输入任意一键返回 ...
	printf("\n\n");
	system("PAUSE");
}

//////////////////////////////////////////////////////////////////////////////


